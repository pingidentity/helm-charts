# This ConfigMap contains an example shell script for running a PingDirectory backup.
# The storage of the created backup is not implemented here.
apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-backup
data:
  backup.sh: |-
    #!/bin/sh
    set -e
    # Create a directory for the backup
    mkdir -p /opt/pingdirectory-backup
    # Run the backup
    backup --backupDirectory /opt/pingdirectory-backup --backendID userRoot --retainPreviousFullBackupAge '1 day'
    # TODO implement based on the environment: upload backup files (to S3 or other storage)

---

# This ConfigMap contains an example shell script for running a PingDirectory restore.
# The downloading of the desired backup is not implemented here.
apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-restore
data:
  restore.sh: |-
    #!/bin/sh
    set -e

    # TODO implement based on the environment: pull down backup files (from S3 or other storage) to SERVER_RESTORE_DIR
    SERVER_RESTORE_DIR=/tmp/restore
    mkdir -p "${SERVER_RESTORE_DIR}"

    # Check if replication is enabled
    REPL_ENABLED=false
    dsreplication status --no-prompt
    test $? -eq 0 && REPL_ENABLED=true
    
    pause_replication () {
      if test "${REPL_ENABLED}" = "true"; then
        echo "Executing pre-initialization from within ${SERVER} pod for DN ${USER_BASE_DN}"
        dsreplication pre-external-initialization \
          --retryTimeoutSeconds 60 \
          --baseDN "${USER_BASE_DN}" \
          --no-prompt --ignoreWarnings
      fi
    }

    resume_replication() {
      if test "${REPL_ENABLED}" = "true"; then
        echo "Initializing replication from within ${SERVER} pod for DN: ${USER_BASE_DN} "
        dsreplication initialize-all \
          --retryTimeoutSeconds 60 \
          --baseDN "${USER_BASE_DN}" \
          --no-prompt --ignoreWarnings

        echo "Executing post-initialization from within ${SERVER} pod for DN: ${USER_BASE_DN}"
        dsreplication post-external-initialization \
          --retryTimeoutSeconds 60 \
          --baseDN "${USER_BASE_DN}" \
          --no-prompt --ignoreWarnings
      fi
    }

    # This guarantees that resume_replication is always run, even if the restore job exits due to an error
    trap "resume_replication" EXIT

    pause_replication

    
    
    # Print listed files from user data archive
    if ! ls ${SERVER_RESTORE_DIR}; then
      echo "Failed to list ${SERVER_RESTORE_DIR}"
      exit 1
    fi
    
    if test -f "${SERVER_ROOT_DIR}/changelogDb"; then
      echo "Removing changelogDb before restoring user data"
    
      if ! rm -rf "${SERVER_ROOT_DIR}/changelogDb"; then
        echo "Failed to remove ${SERVER_RESTORE_DIR}/changelogDb"
        exit 1
      fi
    fi
    
    echo "Restoring to the latest backups under ${SERVER_RESTORE_DIR}"
    BACKEND_DIRS=$(find "${SERVER_RESTORE_DIR}" -name backup.info -exec dirname {} \;)
    
    # If encryption-settings backend is present in the backups, it must be restored first.
    # So re-order the backups such that it appears first in the list.
    ORDERED_BACKEND_DIRS=
    ENCRYPTION_DB_BACKEND_DIR=
    
    for BACKEND_DIR in ${BACKEND_DIRS}; do
      if test "${BACKEND_DIR%encryption-settings}" != "${BACKEND_DIR}"; then
        echo "Found encryption-settings database backend"
        ENCRYPTION_DB_BACKEND_DIR="${BACKEND_DIR}"
      else
        test -z "${ORDERED_BACKEND_DIRS}" &&
            ORDERED_BACKEND_DIRS="${BACKEND_DIR}" ||
            ORDERED_BACKEND_DIRS="${ORDERED_BACKEND_DIRS} ${BACKEND_DIR}"
      fi
    done
    
    test ! -z "${ENCRYPTION_DB_BACKEND_DIR}" &&
        ORDERED_BACKEND_DIRS="${ENCRYPTION_DB_BACKEND_DIR} ${ORDERED_BACKEND_DIRS}"
    
    echo "Restore order of backups: ${ORDERED_BACKEND_DIRS}"
    
    for BACKEND_DIR in ${ORDERED_BACKEND_DIRS}; do
      printf "\n----- Doing a restore from ${BACKEND_DIR} -----\n"
      restore --task \
        --useSSL --trustAll \
        --port ${LDAPS_PORT} \
        --bindDN "${ROOT_USER_DN}" \
        --bindPasswordFile "${ROOT_USER_PASSWORD_FILE}" \
        --backupDirectory "${BACKEND_DIR}" \
        --ignoreCompatibilityWarnings
    done
    
    # Cleanup
    rm -rf ${SERVER_RESTORE_DIR}

    echo "Restore complete"

